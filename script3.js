/* NOTES - How JS works behind the scenes */

/* Parsers and Engines *******
JS is run in the browser by a JS engine (such as V8 in chrome).
The engine parses the code to check it is valid JS language.  If it isn't the engine will throw an error.
If it is valid, it will produce a data structure called the Abstract Syntax Tree.
It is then converted to Machine Code and run on the Machine.
*/

/* Execution Contexts and the Execution Stack *********
Global Execution Context - code that is not within a function.
Any code in the GEC will be executed.
Associated with the Global Object, which in the browser is the Window Object.
*/

// var lastName = "Hart";

// function first() {
//     var a = "Hello!"
//     second()
//     var x = a + lastName
// }
// function second() {
//     var b = "Hi!"
//     third()
//     var z = b + lastName
// }
// function third() {
//     var c = "Hey!"
//     var z = c + lastName

// }

// Every time one of these functions is called, it recieves its own EXECUTION CONTEXT.
// first() // runs in the first() execution context.  And so on and so forth.  They run on top of each other
// in the order that they are called (pushed onto the stack).
// After function RETURNS (ends), it is popped off the stack, and then the second function is popped off, and then the first.

//  The Execution Context Object contains:
//  Variable Object (VO) - contains function arguments, variable declarations, and function declarations
//  Scope Chain - Current var objects, as well as all parent var objects
//  The "this" variable.

//  When new function is called, a new EXECUTION CONTEXT is put on top of the execution stack.
//  This happens in two stages - the CREATION phase and the EXECUTION phase.
//  In the CREATION phase, the VO is created, then the Scope Chain, then the "this" value is determined.
//  In the EXECUTION phase, the code that is generated by the function in the current EXECUTION CONTEXT is
//    run line by line.

//  Creation of Variable Object (VO):
//  1. Argument Object created, containing all of the arguments passed into the function.
//  2. Code is scanned for funtion declarations, and for each function, a property is created in the VO, pointing
//    to that function.
//  This means all functions are stored inside the VO.
//  3. Lastly, the code is scanned for variable declarations.  For each variable, a property is created in the VO,
//    and set to **undefined**.  They will only be **defined** in the execution phase.
//  Points 2 and 3 are what is known as **hoisting** - functions and vars are hoisted in JS.
//  This allows the vars and functions to be available before EXECUTION phase starts.

///////////////////////////////////////
// Lecture: Hoisting

// calcAge(1996);
// // We can first use function and then declare it
// function calcAge(year) {
//   console.log(2020 - year);
// }

// // function EXPRESSION
// calcRetire(1991);
// // Here it does not work - hoisting only works for function declarations

// var calcRetire = function (year) {
//   console.log(65 - (2020 - year));
// };

///////////////////////////////////////
// Lecture: Scoping

// First scoping example

/*
var a = 'Hello!';
first();

function first() {
    var b = 'Hi!';
    second();

    function second() {
        var c = 'Hey!';
        console.log(a + b + c);
    }
}
*/

// Example to show the differece between execution stack and scope chain

/*
var a = 'Hello!';
first();

function first() {
    var b = 'Hi!';
    second();

    function second() {
        var c = 'Hey!';
        third()
    }
}

function third() {
    var d = 'John';
    console.log(a + b + c + d);
}
*/

/* Scope */
// Scope of vars below can be accessed by child functions - they can access parent vars.  They first "search" for the var in their own current scope,
// only if not found do they then look for the var in parent/global scopes
// var a = "hello";
// first();

// function first() {
//   var b = "Hi";
//   second();

//   function second() {
//     var c = "hey";
//     var a = "do"
//     console.log(a + b + c);
//   }
// }
// Scope chain only works upwards and is not the same as thee execution stack, which defines the order in which functions are called - lexically.
///////////////////////////////////////

// Lecture: The this keyword
// Every execution context gets a "this" keyword, stored in execution context object.
// The this keyword is not assigned a value until a function where it is defined is called.

// console.table(globalThis) // same as this in global context
// console.log(this)
// calcAge(1991);

// function calcAge(year) {
//   console.log(2020 - year);
//   console.log(this); // logs out window object, as this is regular function call, not a method.
// }

var nate = {
  name: "Nate",
  yob: 1991,
  calcAge: function () {
    console.log(this); // logs out the nate object, as this refers to object that called the method.
    console.log(2020 - this.yob);
    /* 
    function innerFunction() {
      console.log(this);
    }
    innerFunction(); // logs out window object.  strange... but this is a regular function call, not a method.
    
    */
  },
};

nate.calcAge();

var mike = {
  name: "Mike",
  yob: 1984,
};

mike.calcAge = nate.calcAge; // method borrowing
mike.calcAge();  // works because the "this" keyword is only assigned once method is called!

